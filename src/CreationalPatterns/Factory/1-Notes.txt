This is where people stop new-ing things like rookies and start controlling object creation like adults ğŸ˜„

Iâ€™ll go from problem â†’ naÃ¯ve code â†’ Factory â†’ when to upgrade, exactly how itâ€™s used in real systems.

1ï¸âƒ£ The core problem Factory solves (why it exists)
NaÃ¯ve code (what not to do)
PaymentProcessor processor;

if (type.equals("CARD")) {
    processor = new CardPaymentProcessor();
} else if (type.equals("UPI")) {
    processor = new UpiPaymentProcessor();
} else if (type.equals("NET_BANKING")) {
    processor = new NetBankingPaymentProcessor();
}

Whatâ€™s wrong here?
âŒ Violates Openâ€“Closed Principle
âŒ Object creation logic scattered everywhere
âŒ Adding a new type = modify 10 files
âŒ High coupling to concrete classes

2ï¸âƒ£ Factory Pattern â€” the idea (in one sentence)

Encapsulate object creation so the caller depends on abstractions, not concrete classes.

Or in plain English:
â€œYou tell me what you want, I decide how to create it.â€

tep 1: Common interface
public interface PaymentProcessor {
    void pay(double amount);
}

Step 2: Implementations
public class CardPaymentProcessor implements PaymentProcessor {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using Card");
    }
}

public class UpiPaymentProcessor implements PaymentProcessor {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using UPI");
    }
}

Step 3: Factory class (â­ key)
public class PaymentProcessorFactory {

    public static PaymentProcessor getProcessor(String type) {
        return switch (type) {
            case "CARD" -> new CardPaymentProcessor();
            case "UPI" -> new UpiPaymentProcessor();
            default -> throw new IllegalArgumentException("Unsupported payment type");
        };
    }
}

Step 4: Client code (clean)
PaymentProcessor processor =
        PaymentProcessorFactory.getProcessor("CARD");

processor.pay(500);


âœ” No new
âœ” No concrete dependency
âœ” One place to change creation logic




6ï¸âƒ£ Common mistakes (you should avoid these)
âŒ Factory returning concrete types
CardPaymentProcessor getProcessor()


â¡ï¸ defeats abstraction

âŒ Huge if-else chain forever

If you see:

if (...) else if (...) else if (...)


Time to refactor to:

Map<String, Supplier<PaymentProcessor>>

7ï¸âƒ£ Production-grade Factory (clean, extensible)
public class PaymentProcessorFactory {

    private static final Map<String, Supplier<PaymentProcessor>> REGISTRY =
            Map.of(
                "CARD", CardPaymentProcessor::new,
                "UPI", UpiPaymentProcessor::new
            );

    public static PaymentProcessor getProcessor(String type) {
        Supplier<PaymentProcessor> supplier = REGISTRY.get(type);
        if (supplier == null) {
            throw new IllegalArgumentException("Unsupported payment type: " + type);
        }
        return supplier.get();
    }
}

Why this is better
âœ” No conditionals
âœ” Easy to extend
âœ” Clean Openâ€“Closed compliance
âœ” Java-8+ idiomatic

8ï¸âƒ£ When Simple Factory is NOT enough

If:

Object creation depends on families
Multiple related products
Environment-based creation (DEV / PROD)

â¡ï¸ You move to Abstract Factory (next pattern)

9ï¸âƒ£ Mental checklist (important for interviews)

When you hear:
â€œcreation logicâ€
â€œdecouple instantiationâ€
â€œruntime selectionâ€
â€œbased on type / config / inputâ€

ğŸ‘‰ Factory Pattern