Let‚Äôs keep building this intuition ladder.
You now have Strategy (vary how), Command (vary what), and next comes:

Template Method Pattern = vary parts of an algorithm, not the algorithm itself.

The Core Idea (in one sentence)
Template Method fixes the skeleton of an algorithm, and lets subclasses customize specific steps.

Key words:
Skeleton is fixed
Steps are variable
Order must not change


Motivation:
Consider a scenario where you have different data parsers (e.g., CSV, XML,
and JSON). Each parser follows the same steps: open file, parse data, and
close file.
Without the Template Method Pattern, you might end up duplicating the
common steps in each parser class.


Problems in code if written badly:
‚óè Code duplication: The openFile() and closeFile() methods are
duplicated in both parsers.
‚óè Any changes to the common logic would require changes in every parser,
violating the DRY (Don‚Äôt Repeat Yourself) principle.


Method Pattern:
Problem: Different parts of an algorithm may need to vary in subclasses, but the
overall structure should remain consistent.
Solution: The Template Method Pattern defines the skeleton of an algorithm in a
base class and lets subclasses override specific steps.
Structure:
‚óè Abstract Class: Defines the algorithm skeleton.
‚óè Concrete Subclasses: Override specific steps of the algorithm.


Adv:
‚óè Code Reuse: Common code is moved to the parent class, promoting reuse
and reducing duplication.
‚óè Flexibility: Subclasses can vary certain steps in the algorithm, while keeping
the overall structure intact.
‚óè Consistency: Ensures that the high-level structure of the algorithm remains
consistent, even when subclass behavior differs.


Use:
UI Frameworks: Rendering a UI element might follow a fixed set of steps (initialize, draw, finish),
but the details of how each element is drawn are left to subclasses.
Document Processing: A framework might define the skeleton for reading, processing, and
saving documents, while specific formats (e.g., Word, PDF) provide their own processing logic.
Game Development: A game loop (initialize, update, render) can be defined in a base class, with
specific games implementing their own logic for updating and rendering.
The Template Method Pattern is ideal for situations where a common algorithm exists, but some
steps may need to be redefined by subclasses. It helps enforce structure and promotes
reusability, while allowing flexibility where needed.


class PdfReport {
    void generate() {
        fetchData();
        formatPdf();
        saveToDisk();
    }
}

class ExcelReport {
    void generate() {
        fetchData();
        formatExcel();
        saveToDisk();
    }
}

What‚Äôs wrong conceptually?
Not duplication alone ‚Äî duplication is just a symptom.
The deeper smell is:
‚ÄúThese classes follow the same algorithmic flow, but differ only in some steps.‚Äù
That‚Äôs the trigger.

The Intuition Trigger üîî

Ask yourself this:
‚ÄúIs the order of steps fixed and important?‚Äù
If YES ‚Üí Template Method candidate
If NO ‚Üí Strategy candidate

Here:
fetch ‚Üí format ‚Üí save
Order is non-negotiable.


What NOT to Do (Common Wrong Refactor)
People often jump to Strategy:

interface Formatter {
    void format();
}

But this fails because:
Strategy allows reordering
Strategy allows partial execution
Strategy hands over control
Here, you do not want flexibility over the algorithm.
You want controlled variation.