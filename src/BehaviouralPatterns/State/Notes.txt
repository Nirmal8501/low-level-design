State Pattern â€” intuition-first, no BS
1ï¸âƒ£ Start with the â€œNormalâ€ Code (Again: not wrong yet)

Imagine a Document or Order or Connection.

class Order {
    enum Status { NEW, PAID, SHIPPED, CANCELLED }

    private Status status;

    public void pay() {
        if (status == Status.NEW) {
            status = Status.PAID;
        } else {
            throw new IllegalStateException();
        }
    }

    public void ship() {
        if (status == Status.PAID) {
            status = Status.SHIPPED;
        } else {
            throw new IllegalStateException();
        }
    }

    public void cancel() {
        if (status == Status.NEW || status == Status.PAID) {
            status = Status.CANCELLED;
        } else {
            throw new IllegalStateException();
        }
    }
}


Looks fine. Works. Shippable.

So again: why bother?



2ï¸âƒ£ Apply Pressure #1: Behavior Changes with State

Read this carefully:

The same method name behaves differently depending on internal state.
Thatâ€™s the smell.
pay() is valid in NEW
pay() is invalid in PAID
cancel() is valid in some states, illegal in others
ğŸ”” Intuition trigger #1
â€œMy objectâ€™s behavior depends on its internal state.â€
That sentence is literally the definition of the State pattern

3ï¸âƒ£ Apply Pressure #2: Conditionals Start Spreading

Now product grows:
refund
return
retry payment
partial shipment
on-hold
fraud review
Every method becomes:
if (state == A) { ... }
else if (state == B) { ... }
else if (state == C) { ... }

ğŸ”” Intuition trigger #2
â€œIâ€™m encoding a state machine using if/else.â€
That is the real problem.
Not â€œtoo many ifsâ€, but implicit state machine logic.

4ï¸âƒ£ Apply Pressure #3: Illegal States Are Everywhere
Nothing prevents this:
status = SHIPPED;
pay(); // illegal but possible

You are now relying on:
runtime checks
exceptions
developer discipline

ğŸ”” Intuition trigger #3
â€œInvalid operations should be impossible, not checked.â€
 is a huge design insight.


5ï¸âƒ£ The Mental Shift (THIS is the State Pattern)
Old mental model (wrong)
â€œObject has state, methods check it.â€
New mental model (right)
â€œState IS the behavior.â€
Instead of:
one object + many ifs
You get:
many state objects
each one knows what is allowed



interface OrderState {
    void pay(OrderContext ctx);
    void ship(OrderContext ctx);
    void cancel(OrderContext ctx);
}



class OrderContext {
    private OrderState state;

    public OrderContext() {
        this.state = new NewState();
    }

    void setState(OrderState state) {
        this.state = state;
    }

    public void pay() {
        state.pay(this);
    }

    public void ship() {
        state.ship(this);
    }

    public void cancel() {
        state.cancel(this);
    }
}


class NewState implements OrderState {
    public void pay(OrderContext ctx) {
        ctx.setState(new PaidState());
    }

    public void ship(OrderContext ctx) {
        throw new IllegalStateException();
    }

    public void cancel(OrderContext ctx) {
        ctx.setState(new CancelledState());
    }
}


class PaidState implements OrderState {
    public void pay(OrderContext ctx) {
        throw new IllegalStateException();
    }

    public void ship(OrderContext ctx) {
        ctx.setState(new ShippedState());
    }

    public void cancel(OrderContext ctx) {
        ctx.setState(new CancelledState());
    }
}


Each state:
knows what is allowed
knows what comes next

7ï¸âƒ£ Why This Is Powerful (The Real Motivation)
âœ… No conditionals
âœ… Illegal transitions are localized
âœ… Behavior is cohesive
âœ… State transitions are explicit
âœ… New states donâ€™t modify existing ones (mostly)

Most importantly:
Youâ€™ve turned a hidden state machine into an explicit one.

8ï¸âƒ£ State vs Strategy (CRITICAL DIFFERENCE)

This is where people mess up.

They look similar, but the intent is totally different.

Aspect  	            State	                                    Strategy
Who chooses	            Object itself	                             Client
Changes over time	    âœ… Yes	                                     âŒ Usually no
Represents	            Condition	                                 Algorithm
Transition logic	    Inside states	                             Outside
â€œI am inâ€¦â€	            Yes	                                         No


Rule of thumb (burn this in):

Strategy: â€œHow should I do this?â€
State: â€œWhat am I right now?â€
If behavior changes because time or events passed â†’ State
If behavior changes because client wants a different algorithm â†’ Strategy

9ï¸âƒ£ When You SHOULD Think â€œState Patternâ€

Think State when:

âœ… Object has clearly defined states
âœ… Behavior changes based on state
âœ… State transitions are meaningful
âœ… You see enum + if/else everywhere
âœ… Youâ€™re modeling workflows / lifecycles
âœ… Illegal operations exist

Classic examples:

TCP connection

Order lifecycle

Media player (playing/paused)

Trading order states

Authentication flow

Circuit breaker

ğŸ”Ÿ When You Should NOT Use State

âŒ Only 1â€“2 states
âŒ No behavioral difference
âŒ State does not affect logic
âŒ Pure data state, no behavior
âŒ Overhead outweighs benefit

Donâ€™t replace a boolean with 5 classes.

11ï¸âƒ£ The â€œSenior Engineerâ€ Litmus Test

Ask yourself:

â€œAm I writing code to prevent illegal actions?â€

If YES â†’ State pattern wants to exist.

State pattern makes illegal states unrepresentable (or at least localized).

12ï¸âƒ£ Final Mental Model (Tattoo This)

State pattern replaces conditionals with polymorphism over time.

Not structure.
Not algorithms.
Time + events.


Pattern Ladder (So Far)
Pattern	Core Question
Strategy	How should this be done?
Command	What action is this?
Template	What must not change?
Iterator	Who controls traversal?
State	What am I right now?