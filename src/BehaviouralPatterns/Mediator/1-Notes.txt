Mediator Pattern ‚Äî Intuition, Motivation, Mental Map
1Ô∏è‚É£ Start with the ‚ÄúNormal‚Äù Code (Again: not wrong yet)

Imagine a UI dialog:
TextBox: username
TextBox: password
Button: login
Checkbox: remember me
Label: error message

Naive code:

class LoginButton {
    private UsernameField username;
    private PasswordField password;
    private ErrorLabel error;

    void click() {
        if (username.isEmpty()) {
            error.show("Username required");
            return;
        }
        if (password.isEmpty()) {
            error.show("Password required");
            return;
        }
        // proceed
    }
}

And then:

class UsernameField {
    PasswordField password;
    LoginButton login;

    void onChange() {
        if (!isEmpty()) {
            login.enable();
        }
    }
}

2Ô∏è‚É£ Apply Pressure #1: Components Start Talking to Each Other

Soon:

Username field enables login button
Password field disables error label
Checkbox affects validation
Error label reacts to everything
Each component holds references to many others.

üîî Intuition trigger #1
‚ÄúEvery component knows about every other component.‚Äù
That‚Äôs tight coupling, but more importantly:
Interaction logic is scattered.

3Ô∏è‚É£ Apply Pressure #2: Interaction Rules Grow
Now product asks:
Disable login if password < 8 chars
Hide error on any input
Enable login only when both fields valid
Disable checkbox if login fails
Where do these rules live?
UsernameField?
PasswordField?
LoginButton?

Answer: Everywhere.

üîî Intuition trigger #2
‚ÄúNo single place knows how the system works.‚Äù
That‚Äôs the real problem.
4Ô∏è‚É£ Apply Pressure #3: Change Becomes Dangerous
Now you change one rule:
‚ÄúLogin button stays disabled until both fields are valid‚Äù
You now must:
modify UsernameField
modify PasswordField
modify LoginButton
You‚Äôll break something. Guaranteed.

üîî Intuition trigger #3
‚ÄúI can‚Äôt reason about interactions anymore.‚Äù

5Ô∏è‚É£ The Core Insight (THIS Is Mediator)
Old mental model (wrong)
‚ÄúComponents collaborate directly.‚Äù
New mental model (right)
‚ÄúComponents talk to ONE coordinator.‚Äù
That coordinator = Mediator.

6Ô∏è‚É£ The Mediator Mental Shift (Very Important)
From:
Component ‚Üî Component ‚Üî Component

To:
Component ‚Üí Mediator ‚Üê Component

Components:
don‚Äôt know about each other
only notify mediator

Mediator:
contains interaction logic
orchestrates behavior

7Ô∏è‚É£ Why This Is NOT Just ‚ÄúHelper Class‚Äù
Mediator is not:
a utility
a god object (if done right)
a service layer

Mediator is:
the place where collaboration rules live



Why Mediator gets (sender, event) ‚Äî not (sender, receiver, event)
Short intuition (then we‚Äôll unpack it):
Because the mediator‚Äôs job is to decide who the receiver should be.
If you already know the receiver, you‚Äôve destroyed the reason Mediator exists.

Now let‚Äôs make that intuition solid.

1Ô∏è‚É£ What Problem Mediator Is Actually Solving
The real problem Mediator solves is many-to-many coupling.
Without Mediator:

A ‚Üî B
A ‚Üî C
B ‚Üî C
C ‚Üî D
