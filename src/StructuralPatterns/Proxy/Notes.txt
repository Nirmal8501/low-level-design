‚óè Problem: Sometimes, direct access to an object might not be desirable due to
reasons such as security, resource optimization, or controlled access.
‚óè Solution: The Proxy Pattern provides a surrogate or placeholder for another
object to control access to it.

1Ô∏è‚É£ Start with the Real Problem (Not the Pattern)

You have an object that works.
But something about accessing it is problematic.
Examples:

Object is expensive to create
Object is remote
Object needs access control
Object needs logging / monitoring
Object should be loaded lazily

Important:

The behavior of the object is correct.
The way it is accessed is not.

That is the key smell.

2Ô∏è‚É£ The Core Intuition Trigger üîî
Ask yourself:

‚ÄúI don‚Äôt want to change what this object does ‚Äî I want to control how it is used.‚Äù
That sentence is the birth of Proxy.

3Ô∏è‚É£ The Mental Model (THIS is Proxy)
Stop thinking:
‚ÄúI need to add behavior to this object‚Äù

Start thinking:
‚ÄúI need a stand-in for this object.‚Äù

A Proxy is:
a substitute
with the same interface
that controls access to the real object
Client doesn‚Äôt know (or care) whether it‚Äôs talking to:
the real object
or a proxy

6Ô∏è‚É£ Why Proxy Is Structural (Important)

Proxy:
does NOT change algorithm
does NOT add domain behavior
changes object relationship
It inserts itself between client and real object.
That‚Äôs pure structure.

7Ô∏è‚É£ The 4 Most Important Types of Proxy (Real World)
This is where Proxy becomes practical.

üîπ 1. Virtual Proxy (Lazy Loading)

Problem: Object is expensive to create.

class ImageProxy implements Image {
    private RealImage image;

    public void display() {
        if (image == null) {
            image = new RealImage("photo.png");
        }
        image.display();
    }
}

Used everywhere:
images
large documents
DB entities (Hibernate proxies)


üîπ 2. Protection Proxy (Access Control)
Problem: Not everyone should call everything.

class SecureServiceProxy implements Service {
    public void request() {
        if (!currentUser.isAdmin()) {
            throw new SecurityException();
        }
        real.request();
    }
}

üîπ 3. Remote Proxy

Problem: Object lives in another process / machine.

class RemoteServiceProxy implements Service {
    public void request() {
        sendHttpRequest();
    }
}

Client thinks it‚Äôs local.
Used in:
RMI
gRPC
REST clients

üîπ 4. Caching Proxy

Problem: Calls are expensive, results repeat.

class CachedServiceProxy implements Service {
    Map<Key, Result> cache;

    public Result request(Key k) {
        return cache.computeIfAbsent(k, real::request);
    }
}


8Ô∏è‚É£ Proxy vs Decorator (CRITICAL DISTINCTION)

This is where people get confused.

Aspect	                Proxy	                            Decorator
Intent	                Control access	                    Add behavior
Transparency	        Often invisible	                    Often explicit
Focus	                Lifecycle / access	                Feature extension
Client awareness	    Usually none	                    Often yes
Number stacked	        Usually 1	                        Many

üîî Intuition Trigger (Repeat)
‚ÄúThis is not business logic ‚Äî this is access logic.‚Äù
That belongs in a Proxy.